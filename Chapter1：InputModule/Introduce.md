## è¿™é‡Œæ˜¯ç¬¬ä¸€ä¸ªè§†é¢‘çš„å†…å®¹
æ³¨æ„è¿™ä¸ªæ–‡ä»¶å¤¹å†…çš„ä¸¤ä¸ªæ¨¡å—æ˜¯1.0ç‰ˆæœ¬ï¼Œåç»­å°†éšç« èŠ‚æ›´æ–°ã€‚
æ›´æ–°çš„æ—¶å€™æˆ‘ä¼šæ ‡å‡º1.0ï¼Œ2.0ç­‰ç¼–å·ã€‚
ç« èŠ‚é¡ºåºæ˜¯æˆ‘å­¦ä¹ å’Œç¼–å†™çš„é¡ºåºï¼Œä»æœ€ç®€å•çš„æ–¹å¼å¼€å§‹é€æ­¥æ·»åŠ åŠŸèƒ½ğŸ˜‹ã€‚

## ä»¥ä¸‹æ˜¯æ–‡æ¡ˆ
å“ˆå–½å¤§å®¶å¥½ï¼Œè¿™é‡Œæ˜¯çŒ«è–„è·ï¼ä½œä¸ºæ¸¸æˆå¼€å‘çš„åˆå­¦è€…ï¼Œä½ æ˜¯ä¸æ˜¯ä¹Ÿé‡åˆ°è¿‡è¿™äº›é—®é¢˜ï¼Ÿ

çœ‹ç€ä¸€å¤§å †apiä¸çŸ¥å¦‚ä½•ä¸‹æ‰‹

æœ‰æ¸¸æˆè®¾è®¡çš„åˆ›æ„ï¼Œä½†åˆ¶ä½œèµ·æ¥åˆä¸çŸ¥é“è¯¥ç”¨åˆ°å“ªäº›åŠŸèƒ½

åšdemoçš„æ—¶é™·å…¥ä»£ç ç»†èŠ‚ï¼Œå†™ç€å†™ç€æ€è·¯å°±ä¹±äº†ï¼Ÿ


åˆ«æ‹…å¿ƒï¼Œè¿™äº›é—®é¢˜æˆ‘éƒ½ç»å†è¿‡ï¼ä»Šå¤©åˆ†äº«ä¸€ä¸ªè¶…å®ç”¨çš„å¿ƒå¾—ï¼šç”¨æ¨¡å—åŒ–æ€ç»´æ­å»ºä½ çš„æ¸¸æˆæ¡†æ¶ã€‚è¿™å°±åƒåœ¨â€œæ¸¸æˆåˆ›æ„â€å’Œâ€œå¤æ‚APIâ€ä¹‹é—´æ­èµ·ä¸€åº§æ¡¥æ¢ï¼Œç”¨å¯å¤ç”¨çš„â€œåŠŸèƒ½ç§¯æœ¨â€æ¥æ„å»ºæ¸¸æˆã€‚

æˆ‘ä»¬åªéœ€è¦ç¼–å†™å¥½ä¸€äº›åŸºæœ¬åŠŸèƒ½ï¼Œæ¯”å¦‚è¾“å…¥ç®¡ç†ï¼Œæ•°æ®ç®¡ç†ï¼Œæ¸¸æˆçŠ¶æ€ï¼Œæ¼”å‡ºï¼Œå°±å¯ä»¥ç”¨ä¸€å¥—ä»£ç åˆ¶ä½œä¸åŒçš„æ¸¸æˆã€‚ç‹¬ç‰¹çš„åŠŸèƒ½åªéœ€è¦å•ç‹¬ç¼–å†™å³å¯ã€‚

ä½œä¸ºè¿™ä¸ªç³»åˆ—çš„ç¬¬ä¸€è®²ï¼Œæˆ‘ä»¬æ¥æ”»å…‹æœ€åŸºç¡€ä¹Ÿæœ€å…³é”®çš„â€”â€”è¾“å…¥ç®¡ç†æ¨¡å—

æˆ‘ä»¬çš„ç›®æ ‡æ˜¯è®¾è®¡ä¸€ä¸ªèƒ½æ»¡è¶³ä»¥ä¸‹éœ€æ±‚çš„ç³»ç»Ÿï¼š

+çµæ´»ç»‘å®šï¼šè½»æ¾é…ç½®æŒ‰é”®

+å®æ—¶æ”¹é”®ï¼šè®©ç©å®¶è‡ªå®šä¹‰æ“ä½œ

+è¿æ‹›ç»„åˆï¼šæ”¯æŒå¤æ‚è¾“å…¥åˆ¤æ–­

+äº‹ä»¶é©±åŠ¨ï¼šè®©è¾“å…¥ä¸å…¶ä»–æ¨¡å—è§£è€¦


æˆ‘ä»¬çŸ¥é“unityæä¾›ä¸‰ç§è¾“å…¥æ–¹å¼ï¼Œåˆ†åˆ«æ˜¯inputç±»å’Œä¸¤ä¸ªè¾“å…¥ç®¡ç†ç³»ç»Ÿã€‚æˆ‘ä»¬ä½¿ç”¨inputç±»æ„å»ºæˆ‘ä»¬è‡ªå·±çš„è¾“å…¥ç®¡ç†ç³»ç»Ÿã€‚

ä½¿ç”¨æ–¹æ³•å¾ˆç®€å•ï¼š

é¦–å…ˆæˆ‘ä»¬å…ˆåˆ›å»ºä¸€ä¸ªç©ºç‰©ä½“ï¼Œå«eventsystemï¼Œç„¶åæŒ‚ä¸Šä¸€ä¸ªè„šæœ¬ï¼Œè¿™æ ·äº‹ä»¶ç³»ç»Ÿå°±å¯ä»¥è¿è¡Œäº†ã€‚ç„¶åå†åˆ›å»ºä¸€ä¸ªç©ºç‰©ä½“ï¼ŒæŒ‚ä¸Šè¾“å…¥ç³»ç»Ÿçš„è„šæœ¬ï¼Œä¿®æ”¹è¾“å…¥ç³»ç»Ÿçš„æŒ‰é”®ç»‘å®šè¿æ‹›å’Œç»„åˆé”®é¢„è®¾ã€‚æœ€åè®©ä»»æ„ç‰©ä½“åœ¨äº‹ä»¶ç³»ç»ŸåŠ å…¥äº‹ä»¶ï¼Œè¿™æ ·åœ¨è¾“å…¥è§¦å‘æ—¶å°±å¯ä»¥æ”¶åˆ°é€šçŸ¥ï¼Œè¿è¡Œæˆ‘ä»¬å†™å¥½çš„å‡½æ•°äº†ã€‚

å…·ä½“åŸç†ä¹Ÿå¾ˆç®€å•ï¼š

äº‹ä»¶ç³»ç»Ÿå…¶å®å°±æ˜¯ä¸€ä¸ªå§”æ‰˜å­—å…¸ã€‚

è¾“å…¥ç³»ç»Ÿåˆ™æ˜¯è°ƒç”¨äº†Inputç±»è½®è¯¢æˆ‘ä»¬ç»‘å®šå¥½çš„æŒ‰é”®ï¼Œå†é€šè¿‡ç¼“å­˜æ•°ç»„å­˜å‚¨æŒ‰é”®å†å²ï¼Œå°±å¯ä»¥å®ç°è¿æ‹›å’Œç»„åˆé”®äº†ã€‚

å…·ä½“çš„ä»£ç æˆ‘ä¼šæ”¾åœ¨githubï¼Œå¤§å®¶å¯ä»¥éšæ„ä¿®æ”¹

ä½ å­¦ä¼šäº†å—ï¼Ÿ

## This is the content of the first video
Note: The two modules in this folder are version 1.0 and will be updated with subsequent chapters.
When updating, I will mark the version number like 1.0, 2.0, etc.
The chapter order follows my learning and development sequence, starting from the simplest methods and gradually adding features ğŸ˜‹.

## Script Below
Hello everyone, this is Catnip! As a beginner in game development, have you ever encountered these problems?

*   Feeling overwhelmed by a massive list of APIs and not knowing where to start.
*   Having game design ideas but not knowing which functions to use to build them.
*   Getting bogged down in code details while making a demo, losing your train of thought.

Don't worry, I've been through all of this too! Today, I'm sharing a super useful insight: **build your game framework using a modular approach**. It's like building a bridge between your "game ideas" and "complex APIs," constructing your game with reusable "functional building blocks."

We just need to write some basic functionalities, like **Input Management, Data Management, Game State, and Presentation**. Then, we can use the same codebase to create different games. Unique features only need to be written separately.

For the first part of this series, let's tackle the most fundamental and crucial moduleâ€”**the Input Management Module**.

Our goal is to design a system that meets the following requirements:

*   **Flexible Binding:** Easily configure key bindings.
*   **Real-time Rebinding:** Allow players to customize controls.
*   **Combo & Combination Support:** Handle complex input detection like combos and key combinations.
*   **Event-Driven:** Decouple input from other modules.

We know Unity offers three input methods: the `Input` class and two Input Management systems. We will use the `Input` class to build our own input management system.

How to use it is very simple:

1.  First, create an empty GameObject called `EventSystem` and attach a script to it. This gets the event system running.
2.  Then, create another empty GameObject and attach the input system script to it. Modify the key bindings, combo, and key combination presets in the input system.
3.  Finally, have any object subscribe to events in the event system. This way, when an input is triggered, it will receive a notification and run the functions we've written.

The core principle is also quite simple:

*   The **Event System** is essentially a dictionary of delegates.
*   The **Input System** uses the `Input` class to poll our bound keys and implements combos/key combinations by storing input history in a cached array.

The specific code will be available on GitHub, and you are free to modify it.

Did you find this helpful?
