## 以下是第七期的内容

更新了UI模块，实现了数据驱动的自动更新功能

## 以下是文案

哈喽大家好，这里是猫薄荷！还记得很久以前我们制作的那个基础UI模块吗？当时它只是一个静态界面，还无法满足我们真正的需求。

这一期，我们要实现的功能是：数据驱动的自动更新功能

当数据模块中的游戏数据被修改时，会触发UI更新事件。这次我们要让UI模块能够响应这个事件，自动更新界面上的所有文本和图片内容。

我们的数据结构如下：

两个静态变量TEXT_NUM和IMAGE_NUM分别用来标记文本数组和图片数组的元素数量

两个GameObject类的数组，用来存储需要自动更新的文本和图片对象

一个字符串InTransAnimationName，存储转场切入动画名称

一个静态变量StatisticIni，用于标记数据模块是否完成初始化

我们的方法如下：

一个UI_Update方法，用于承担核心的UI更新功能，内部两个循环，分别用于更新文本和图像。它会检查每个元素的名字，取出最后一个字符当作存档的序号，其余字符当作键在存档中寻找值。对于文本来说，就是直接将值取出，对于图像，则是在resources文件夹查找对应的图片资源

一个SwitchObjectTrigger函数，用于触发游戏物体交换事件，游戏模块会执行对应的功能，这里只是供UI调用。

一个Onenable函数，用于在数据模块初始化结束，并且界面被激活时更新UI，确保界面激活时UI可以自动更新。

start函数中我们只需要简单地注册UI更新事件

其他模块的配合调整：

数据模块的start函数末尾，我们需要将UI模块的初始化标记赋值为true，并且触发一次UI更新，确保界面的初始状态正确。

接下来是使用方法：

一、将新脚本挂载到之前制作的主界面和存档选择界面上

二、重命名所有需要自动更新的文本和图像对象。格式为数据键名+存档序号

三、将文本和图像对象分别拖入对应的数组

让我们来看看效果：

这个调试脚本只包含数据修改函数，当我们点击按钮时：

只会修改存档0的数据。

文本和图像的更新由我们的UI模块自动进行。

日志中清晰显示整个更新过程。

通过这样的设计，我们实现了真正意义上的数据驱动UI，让界面能够实时响应游戏数据的变化！
